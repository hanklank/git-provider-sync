// SPDX-FileCopyrightText: 2024 Josef Andersson
//
// SPDX-License-Identifier: EUPL-1.2
package gitlab

import (
	"context"
	"fmt"
	"net/http"

	"itiquette/git-provider-sync/internal/log"
	"itiquette/git-provider-sync/internal/model"
	config "itiquette/git-provider-sync/internal/model/configuration"
	"itiquette/git-provider-sync/internal/provider/targetfilter"

	"github.com/xanzy/go-gitlab"
)

// APIClient represents a facade to GitLab API operations.
type APIClient struct {
	raw               *gitlab.Client
	projectService    *ProjectService
	protectionService *ProtectionService
	filterService     *filterService
}

func (api APIClient) CreateProject(ctx context.Context, cfg config.ProviderConfig, opt model.CreateProjectOption) (string, error) {
	logger := log.Logger(ctx)
	logger.Trace().Msg("Entering GitLab:CreateProject")
	opt.DebugLog(logger).Msg("GitLab:CreateOption")

	projectIDStr, err := api.projectService.createProject(ctx, cfg, opt)
	if err != nil {
		return "", fmt.Errorf("failed to create a GitLab project: %w", err)
	}

	return projectIDStr, nil
}

func (api APIClient) IsValidProjectName(ctx context.Context, name string) bool {
	logger := log.Logger(ctx)
	logger.Trace().Msg("Entering GitLab:IsValidProjectName")
	logger.Debug().Str("name", name).Msg("GitLab:IsValidProjectName")

	if !IsValidGitLabRepositoryName(name) || !isValidGitLabRepositoryNameCharacters(name) {
		logger.Debug().Str("name", name).Msg("Invalid GitLab repository name")
		logger.Debug().Msg("See https://docs.gitlab.com/ee/user/reserved_names.html")

		return false
	}

	return true
}

func (APIClient) Name() string {
	return config.GITLAB
}

func (api APIClient) ProjectInfos(ctx context.Context, cfg config.ProviderConfig, filtering bool) ([]model.ProjectInfo, error) {
	logger := log.Logger(ctx)
	logger.Trace().Msg("Entering GitLab:ProjectInfos")
	logger.Debug().Bool("filtering", filtering).Msg("GitLab:ProjectInfos")

	projectInfos, err := api.projectService.getRepositoryProjectInfos(ctx, cfg)
	if err != nil {
		return nil, fmt.Errorf("failed to get project infos. err: %w", err)
	}

	if filtering {
		return api.filterService.FilterProjectinfos(ctx, cfg, projectInfos, targetfilter.FilterIncludedExcludedGen(), targetfilter.IsInInterval)
	}

	return projectInfos, nil
}

func (api APIClient) ProtectProject(ctx context.Context, _ string, defaultBranch string, projectIDstr string) error {
	logger := log.Logger(ctx)
	logger.Trace().Msg("Entering GitLab:ProtectProject")
	logger.Debug().Str("defaultBranch", defaultBranch).Str("projectIDStr", projectIDstr).Msg("GitLab:ProtectProject")

	err := api.protectionService.protect(ctx, defaultBranch, projectIDstr)
	if err != nil {
		return fmt.Errorf("failed to to protect  %s: %w", projectIDstr, err)
	}

	return nil
}

func (api APIClient) SetDefaultBranch(ctx context.Context, owner, repo, branch string) error {
	logger := log.Logger(ctx)
	logger.Trace().Msg("Entering GitLab:SetDefaultBranch")
	logger.Debug().Str("owner", owner).Str("repo", repo).Str("branch", branch).Msg("GitLab:SetDefaultBranch")

	err := api.projectService.setDefaultBranch(ctx, owner, repo, branch)
	if err != nil {
		return fmt.Errorf("failed to set default branch: %s, for repo: %s with owner: %s, err: %w", branch, repo, owner, err)
	}

	return nil
}

func (api APIClient) UnprotectProject(ctx context.Context, branch string, projectIDStr string) error {
	logger := log.Logger(ctx)
	logger.Trace().Msg("Entering GitLab:Unprotect")
	logger.Debug().Str("projectIDStr", projectIDStr).Str("branch", branch).Msg("GitLab:Unprotect")

	err := api.protectionService.unprotect(ctx, branch, projectIDStr)
	if err != nil {
		return fmt.Errorf("failed to to unprotect %s: %w", projectIDStr, err)
	}

	return nil
}

func NewGitLabAPIClient(ctx context.Context, option model.GitProviderClientOption, httpClient *http.Client) (APIClient, error) {
	logger := log.Logger(ctx)
	logger.Trace().Msg("Entering GitLab:NewGitLabClient")

	defaultBaseURL := "https://gitlab.com/"
	if option.Domain != "" {
		defaultBaseURL = option.DomainWithScheme(option.HTTPClient.Scheme)
	}

	rawClient, err := gitlab.NewClient(option.HTTPClient.Token,
		gitlab.WithBaseURL(defaultBaseURL),
		gitlab.WithHTTPClient(httpClient),
	)
	if err != nil {
		return APIClient{}, fmt.Errorf("create new GitLab client: %w", err)
	}

	return APIClient{
		raw:               rawClient,
		projectService:    NewProjectService(rawClient),
		protectionService: NewProtectionService(rawClient),
		filterService:     NewFilter(nil),
	}, nil
}
